## Pràctica 1. Contenidors

Es tracta de crear i orquestrar un parell de contenidors, amb les següents característiques:

**Base de dades**, amb les següents característiques:

1. Contindrà un servidor de bases de dades mysql, escoltant al port 3306
2. Deu crear una base de dades amb nom `alumnes`
3. L'usuari administrador tindrà com a password `toor`
4. Es carregarà el següent script
    ```sql
    use alumnes;

    CREATE TABLE students(
        StudentID int not null AUTO_INCREMENT,
        FirstName varchar(100) NOT NULL,
        Surname varchar(100) NOT NULL,
        PRIMARY KEY (StudentID)
    );

    INSERT INTO students (FirstName, Surname) VALUES ('Tony', 'Stark');
    INSERT INTO students (FirstName, Surname) VALUES ('Steve', 'Rogers');
    INSERT INTO students (FirstName, Surname) VALUES ('Bruce', 'Banner');
    INSERT INTO students (FirstName, Surname) VALUES ('Natasha', 'Romanoff');
    INSERT INTO students (FirstName, Surname) VALUES ('Thor', 'Odinson');
    INSERT INTO students (FirstName, Surname) VALUES ('Peter', 'Parker');
    INSERT INTO students (FirstName, Surname) VALUES ('Wanda', 'Maximoff');
    INSERT INTO students (FirstName, Surname) VALUES ('Scott', 'Lang');
    INSERT INTO students (FirstName, Surname) VALUES ('Carol', 'Danvers');
    INSERT INTO students (FirstName, Surname) VALUES ('T''Challa', 'Wakanda');
    ```
    Això es fa afegint al Dockerfile corresponent aquesta linia `COPY ./init.sql /docker-entrypoint-initdb.d/`

**Programa en Python**, amb les següents característiques

1. Es deu de crear un contenidor que requereix python
2. Es copiarà el programa següent dins del contenidor
    ```python
    import mysql.connector

    connection = mysql.connector.connect(
        user='root', password='toor', host='db', port="3306", database='alumnes')
    print("DB connected")

    cursor = connection.cursor()

    def show_students():
        
        # Execute the query
        cursor.execute('SELECT * FROM students')

        # Fetch the results
        students = cursor.fetchall()

        # Print the results
        for student in students:
            print(student)

    show_students()

    connection.close()
    ```

3. S'executarà el programa només arrancar el contenidor. El programa mostrarà els registres que s'han inserit al crear la base de dades.

 


## Pràctica 2. Scraping de [tiempo.es](http://tiempo.es)

Revisant els continguts creats es tracta de crear un projecte que realitze un scrapping de una part de tiempo.es. Volem concretament saber l'oratge de les principals ciutats de la província de València, i per això revisarem els continguts que ens ofereix <https://www.tiempo.es/valencia-es2509951.html>

Es demana docs, crear un dataset on tindràs per a cada ciutat la previsió del dia actual. Les zones a capturar son les que segueixen:

 
<center>![Capturar el temps](./img/PRA_scrap.png){width=75%}</center>

## Pràctica 3. App per a dissenyar XXNN

Anem a fer en aquest cas pràctic una aplicació que ens permetrà dissenyar una XXNN. El programa presentarà a la seua interfície un formulari en el qual li indicarem:

- Dimensió de la entrada de la xarxa
- Per a cada capa:
  - Número de neurones de la mateixa
  - Tipus de capa
  - Funció d'activació  
- Funció de callback de parada, amb els paràmetres de delta, paciencia i guardat de mínims. 

!!! info "Disseny"

    - Pensa que el número de capes pot variar, així que a la pantalla podrem afegir o llevar files segons el número de capes.
    - Fixa't també que no totes les capes tenen el mateix número d'atributs
  
El programa generarà un JSON, similar a aquest:

```json
{
  "input":4,
  "layers":[
    {
      "layer":'Dense',
      "neurons":8,
      "act":'relu'
    },
    {
      "layer":'Dense',
      "neurons":32,
      "act":'selu'
    },
         {
      "layer":'BatchNormalization'
    }
    {
      "layer":'Dense',
      "neurons":2,
      "act":'relu'
    }
    "stop":{
      "min_delta":0.001,
      "patience":5, 
      "restore_best_weights":True
    }
  ]
}
```

Ademes:

- Fer una funció que a partir del json anterior, cree el model.
- Un cop creat el model, entrenara amb un únic DataFrame ja preparat i netejat, per a no complicar més el disseny.
- En acabar l'entrenament es guardarà a disc el model entrenat i el json en la configuració del mateix.
- Un cop entrenat, dibuixarà el gràfic de les funcions de pèrdua. 
- Ha de permetre també modificar el disseny de la xarxa, tornar-la a entrenar i dibuixar un nou gràfic (sense perdre el primer ni els anteriors) per veure l'evolució del mateix.




## Pràctica 4. Consum de API

Per a concloure, anem a fer una aplicació client d'una API del temps <https://www.el-tiempo.net/api>. A la qual es presentaran 2 quadres de selecció desplegable, un per a provincia i altre per a municipi.

En obrir el programa es consumirà la API per a seleccionar les provincies. Amb aquesta informació s'omplirà el quadre de l'esquerre (Provincia).

En seleccionar la provincia, es consumirà la API i s'ompliran tots els municipis al seleccionable de la dreta. 

When the municipality is selected, the API will be consumed and the weather forecast for that municipality will be retrieved. General information for the day will be presented, and graphs with temperature, wind speed, and precipitation forecasts should be displayed.

